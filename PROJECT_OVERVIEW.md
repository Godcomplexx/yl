# Технический Обзор Проекта: Cinematic Dataset Collector

Этот документ содержит подробное описание каждого компонента проекта, его логики и ключевых функций.

---

## 1. `config.yaml` - Файл Конфигурации

Это центр управления всем пайплайном. Здесь задаются все ключевые параметры, что позволяет гибко настраивать процесс без изменения кода.

- **`paths`**: Определяет пути для хранения логов, временных файлов и итогового датасета.
- **`keywords`**: Список ключевых слов для поиска видео на YouTube. Основа для сбора тематического контента.
- **`scraper`**: Настройки для модуля скачивания:
  - **Фаза 1: Сбор метаданных.** Скрипт использует `yt-dlp` для поиска видео по ключевым словам, но **не скачивает их**. Он запрашивает только метаданные: название, URL и, самое главное, **длительность**.
  - **Фаза 2: Фильтрация.** Все найденные видео проверяются на соответствие параметру `max_video_duration` из конфига. Слишком длинные ролики (фильмы, стримы) отбрасываются. Это защищает от скачивания гигабайтных файлов.
  - **Фаза 3: Загрузка.** Только после фильтрации подходящие короткие видео скачиваются в папку для временного хранения (`dataset/raw`).
- **`processing`**: Настройки для модуля обработки:
  - **`clip_duration`**: Длительность финальных клипов в секундах.

---

## 2. `src/utils/logger.py` - Настройка Логирования

Этот небольшой модуль отвечает за создание и настройку логгера. Он гарантирует, что все события, ошибки и информационные сообщения записываются как в консоль, так и в ротируемый файл `logs/run.log`. Это крайне важно для отладки и мониторинга.

---

## 3. `src/scrapers/` - Модуль Поиска и Загрузки (Архитектура "Стратегия")

**Задача:** Обеспечить гибкий и расширяемый способ сбора видео из разных источников.

Для этого мы применили паттерн проектирования "Стратегия". Вместо одного монолитного файла `scraper.py` теперь существует целая папка `src/scrapers`:

- **`base_scraper.py`**: Определяет "контракт" — абстрактный класс `ScraperStrategy` с единым методом `search_and_download`. Любой новый скрапер для другой платформы (TikTok, Vimeo) должен будет наследовать этот класс и реализовать этот метод.

- **`youtube_scraper.py`**: Конкретная реализация стратегии для YouTube. Содержит всю логику, которая раньше была в `scraper.py`, но теперь аккуратно упакована в класс `YouTubeScraper`.

- **`__init__.py`**: Делает эту папку Python-пакетом.

**Как это работает:**

1. В `config.yaml` появился новый список `active_scrapers`.
2. `main.py` читает этот список и для каждого элемента (например, `'youtube'`) находит соответствующий класс (например, `YouTubeScraper`).
3. Создается экземпляр этого класса, и вызывается его метод `search_and_download`.

**Преимущество:** Чтобы добавить поддержку новой платформы, достаточно создать новый файл (например, `tiktok_scraper.py`), реализовать в нем свою логику и просто добавить `'tiktok'` в список `active_scrapers` в конфиге. Остальной код менять не придется.

---

## 4. `src/processing.py` - Модуль Обработки Видео

**Задача:** Превратить сырые скачанные видео в качественные, уникальные клипы.

**Ключевые функции:**

- **`trim_video`**: Из каждого длинного видео вырезается случайный фрагмент заданной длительности (`clip_duration`).
- **`calculate_video_hash`**: Для каждого клипа вычисляется перцептивный хеш с помощью библиотеки `videohash`. Этот хеш представляет собой "цифровой отпечаток" видео.
- **`is_duplicate`**: Сравнивает хеш нового клипа с хешами уже добавленных в датасет. Если находится слишком похожий, клип помечается как дубликат и отбрасывается.
- **`detect_watermark`**: Самая сложная функция в модуле. Она реализует "умную" детекцию водяных знаков с помощью `OpenCV`:

  1. Берет два кадра из разных частей клипа.
  2. Находит на них общие характерные точки (features) с помощью алгоритма ORB.
  3. Сопоставляет эти точки и вычисляет матрицу гомографии, чтобы "совместить" один кадр с другим, компенсируя движение камеры.
  4. Один кадр "накладывается" на другой с учетом этого движения (вычисляется гомография).
  5. Вычисляется разница между совмещенными кадрами. В результате движущиеся объекты сцены исчезают, а статичные элементы (водяные знаки) остаются видимыми.
  6. Если площадь таких статичных областей превышает заданный порог, видео помечается как содержащее водяной знак и отбраковывается.

---

## 5. `src/main.py` - Главный Оркестратор

**Задача:** Управлять всем процессом от начала до конца.

**Логика функции `main`:**

1. **Инициализация:** Загружает `config.yaml`, настраивает логгер с помощью `setup_logger`.
2. **Скачивание:** Динамически запускает скраперы, указанные в `active_scrapers` из конфига, для сбора сырых видео.
3. **Основной цикл обработки:**
    - Итерируется по каждому скачанному видео.
    - Вызывает `trim_video` для нарезки клипа.
    - Вызывает `detect_watermark` для проверки на наличие водяных знаков. Если найден — переход к следующему видео.
    - Вызывает `calculate_video_hash` и `is_duplicate` для проверки на уникальность. Если дубликат — переход к следующему видео.
    - Если все проверки пройдены, клип перемещается в финальную папку (`dataset/clips/<keyword>`), а его метаданные добавляются в список для будущего `index.csv`.
4. **Финализация:**
    - Создает `index.csv` из собранных метаданных.
    - Генерирует `report.md` со статистикой (сколько клипов собрано по каждому тегу).
    - Упаковывает всю папку `dataset` в `dataset.zip`.
    - Удаляет временные папки.
